/*
 * Copyright 2011 James Moger.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.iciql;

import com.iciql.util.StatementBuilder;
import com.iciql.util.StringUtils;

/**
 * Derby database dialect.
 */
public class SQLDialectDerby extends SQLDialectDefault {

    @Override
    public Class<? extends java.util.Date> getDateTimeClass() {
        return java.sql.Timestamp.class;
    }

    @Override
    public String convertSqlType(String sqlType) {
        if ("TINYINT".equals(sqlType)) {
            // Derby does not have a TINYINT/BYTE type
            return "SMALLINT";
        }
        return sqlType;
    }

    @Override
    public void appendLimitOffset(SQLStatement stat, long limit, long offset) {
        // FETCH/OFFSET added in 10.5
        if (databaseMajorVersion >= 10 && databaseMinorVersion >= 5) {
            if (offset > 0) {
                stat.appendSQL(" OFFSET " + offset + (offset == 1 ? " ROW" : " ROWS"));
            }
            if (limit > 0) {
                stat.appendSQL(" FETCH NEXT " + limit + (limit == 1 ? " ROW" : " ROWS") + " ONLY");
            }
        }
    }

    @Override
    protected boolean prepareColumnDefinition(StatementBuilder buff, String dataType,
                                              boolean isAutoIncrement, boolean isPrimaryKey) {
        String convertedType = convertSqlType(dataType);
        buff.append(convertedType);
        if (isIntegerType(dataType) && isAutoIncrement) {
            buff.append(" GENERATED BY DEFAULT AS IDENTITY");
        }
        return false;
    }

    @Override
    public String prepareColumnConstraint(boolean isAutoIncrement, boolean isPrimaryKey, boolean nullable, Class<?> fieldType, String dataType, String defaultValue) {
        StringBuilder sb = new StringBuilder();
        if (!isAutoIncrement && !isPrimaryKey) {

            if (nullable && (defaultValue == null || ((dataType.equals("TIMESTAMP") || dataType.equals("DATETIME")) && StringUtils.isNullOrEmpty(defaultValue)))) {
                sb.append(" DEFAULT NULL");
            } else if (!StringUtils.isNullOrEmpty(defaultValue)) {
                if (ModelUtils.isProperlyFormattedDefaultValue(defaultValue)
                        && ModelUtils.isValidDefaultValue(fieldType, defaultValue)) {
                    sb.append(" DEFAULT ").append(defaultValue);
                }
            }
        }

        if (!nullable) {
            sb.append(" NOT NULL");
        }
        return sb.toString();
    }

    @Override
    public <T> void prepareDropTable(SQLStatement stat, TableDefinition<T> def) {
        StatementBuilder buff = new StatementBuilder("DROP TABLE "
                + prepareTableName(def.schemaName, def.tableName));
        stat.setSQL(buff.toString());
        return;
    }

    @Override
    public <T, A> void prepareBitwiseAnd(SQLStatement stat, Query<T> query, A x, A y) {
        throw new IciqlException("{0} does not support bitwise operator AND", databaseName);
    }

    @Override
    public <T, A> void prepareBitwiseXor(SQLStatement stat, Query<T> query, A x, A y) {
        throw new IciqlException("{0} does not support bitwise operator XOR", databaseName);
    }

}